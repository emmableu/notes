"use strict";(self.webpackChunknotes=self.webpackChunknotes||[]).push([[5723],{28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var i=t(96540);const s={},r=i.createContext(s);function o(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:n},e.children)}},43857:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"Leetcode/Binary Search/1428.1428 - Leftmost Column with at Least a One - Medium","title":"1428.1428 - Leftmost Column with at Least a One - Medium","description":"LC link","source":"@site/docs/Leetcode/02.Binary Search/1428.1428 - Leftmost Column with at Least a One - Medium.md","sourceDirName":"Leetcode/02.Binary Search","slug":"/p/d40e3fc4-ebce-4130-9663-fc5ab13f9aa6","permalink":"/notes/docs/p/d40e3fc4-ebce-4130-9663-fc5ab13f9aa6","draft":false,"unlisted":false,"editUrl":"https://github.com/emmableu/notes/edit/main/docs/Leetcode/02.Binary Search/1428.1428 - Leftmost Column with at Least a One - Medium.md","tags":[],"version":"current","frontMatter":{"created_at":"2025-10-23","page_link":"/p/d40e3fc4-ebce-4130-9663-fc5ab13f9aa6","slug":"/p/d40e3fc4-ebce-4130-9663-fc5ab13f9aa6"},"sidebar":"tutorialSidebar","previous":{"title":"1146.1146 - Snapshot Array - Medium","permalink":"/notes/docs/p/e7fe562f-68f9-4060-9d9d-065d2611ccd1"},"next":{"title":"152.152 - 300-Longest Increasing Subsequence - Medium","permalink":"/notes/docs/p/13035f81-c3c7-4f18-b46b-b4a67a45c745"}}');var s=t(74848),r=t(28453);const o={created_at:"2025-10-23",page_link:"/p/d40e3fc4-ebce-4130-9663-fc5ab13f9aa6",slug:"/p/d40e3fc4-ebce-4130-9663-fc5ab13f9aa6"},a=void 0,l={},c=[{value:"Description:",id:"description",level:2},{value:"Examples",id:"examples",level:2},{value:"Constraints:",id:"constraints",level:2},{value:"Method 1: (most efficient) top-right =&gt; down-left (O(m+n))",id:"method-1-most-efficient-top-right--down-left-omn",level:2},{value:"Method 2: (not efficient enough solution:) Binary search (O(m*lgn))",id:"method-2-not-efficient-enough-solution-binary-search-omlgn",level:2},{value:"Implementation (based on this not-so-efficient method:)",id:"implementation-based-on-this-not-so-efficient-method",level:3}];function d(e){const n={a:"a",br:"br",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/leftmost-column-with-at-least-a-one/solution/",children:"LC link"})}),"\n",(0,s.jsx)(n.h2,{id:"description",children:"Description:"}),"\n",(0,s.jsx)(n.p,{children:"A row-sorted binary matrix means that all elements are 0 or 1 and each row of the matrix is sorted in non-decreasing order."}),"\n",(0,s.jsx)(n.p,{children:"Given a row-sorted binary matrix binaryMatrix, return the index (0-indexed) of the leftmost column with a 1 in it. If such an index does not exist, return -1."}),"\n",(0,s.jsx)(n.p,{children:"You can't access the Binary Matrix directly. You may only access the matrix using a BinaryMatrix interface:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"BinaryMatrix.get(row, col)"})," returns the element of the matrix at index (row, col) (0-indexed)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"BinaryMatrix.dimensions()"})," returns the dimensions of the matrix as a list of 2 elements [rows, cols], which means the matrix is rows x cols.\nSubmissions making more than 1000 calls to BinaryMatrix.get will be judged Wrong Answer. Also, any solutions that attempt to circumvent the judge will result in disqualification."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"For custom testing purposes, the input will be the entire binary matrix mat. You will not have access to the binary matrix directly."}),"\n",(0,s.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Input: mat = [[0,0],[1,1]]\nOutput: 0\n\nInput: mat = [[0,0],[0,1]]\nOutput: 1\n\nInput: mat = [[0,0],[0,0]]\nOutput: -1\n"})}),"\n",(0,s.jsx)(n.h2,{id:"constraints",children:"Constraints:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"rows == mat.length"}),"\n",(0,s.jsx)(n.li,{children:"cols == mat[i].length"}),"\n",(0,s.jsx)(n.li,{children:"1 <= rows, cols <= 100"}),"\n",(0,s.jsx)(n.li,{children:"mat[i][j] is either 0 or 1."}),"\n",(0,s.jsx)(n.li,{children:"mat[i] is sorted in non-decreasing order."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"method-1-most-efficient-top-right--down-left-omn",children:"Method 1: (most efficient) top-right => down-left (O(m+n))"}),"\n",(0,s.jsxs)(n.p,{children:["\u4ece\u53f3\u4e0b\u89d2\u5f00\u59cb\uff0c\u9047\u52301\u5f80\u5de6\u8d70\uff0c\u9047\u52300\u5f80\u4e0a\u8d70\uff0c\u8d70\u5230\u7b2c\u4e00\u884c",(0,s.jsx)(n.br,{}),"\n\u5de6\u53f3\u65b9\u5411\uff1a\u8d1f\u8d23\u6bd4\u5927\u5c0f",(0,s.jsx)(n.br,{}),"\n\u4e0a\u4e0b\u65b9\u5411\uff1a\u8d1f\u8d23\u904d\u5386"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"class Solution:\n    def leftMostColumnWithOne(self, binaryMatrix):\n        [m, n] = binaryMatrix.dimensions()\n        r, c = m-1, n-1\n        while r >= 0 and c >= 0:\n            if binaryMatrix.get(r, c) == 1:\n                c -= 1\n            else:\n                r -= 1\n        return -1 if c==n-1 else c+1\n"})}),"\n",(0,s.jsx)(n.h2,{id:"method-2-not-efficient-enough-solution-binary-search-omlgn",children:"Method 2: (not efficient enough solution:) Binary search (O(m*lgn))"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"- binary search\n- update right threshold for each row\n"})}),"\n",(0,s.jsx)(n.h3,{id:"implementation-based-on-this-not-so-efficient-method",children:"Implementation (based on this not-so-efficient method:)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"class Solution:\n    def leftMostColumnWithOne(self, binaryMatrix):\n        [m, n] =  binaryMatrix.dimensions() #remember to not use len() here.\n        res = -1\n        for i in range(m):\n            l = -1\n            if i == 0:\n                r = n\n            else:\n                r = res  #first time: used r = res+1, this caused [[0,0], [0, 0]] here has r = 3, exceeding bounds.\n            while l + 1 < r:\n                mid = (l + r)//2\n                if binaryMatrix.get(i, mid) == 1:\n                    r = mid\n                else:\n                    l = mid\n            res = l + 1\n        # first time: only returns res. This caused inputs like [[0, 0], [0, 0]] to return 2\n        return -1 if res == n else res\n"})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);