"use strict";(self.webpackChunknotes=self.webpackChunknotes||[]).push([[6645],{28453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>l});var t=i(96540);const s={},r=t.createContext(s);function o(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(r.Provider,{value:n},e.children)}},82154:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"Leetcode/Other/973.973 - K Closest Points to Origin - Medium","title":"973.973 - K Closest Points to Origin - Medium","description":"solution 1: quick select (preferred)","source":"@site/docs/Leetcode/99.Other/973.973 - K Closest Points to Origin - Medium.md","sourceDirName":"Leetcode/99.Other","slug":"/p/5e39533c-1dcd-4c36-85ef-f0adb0a70417","permalink":"/notes/docs/p/5e39533c-1dcd-4c36-85ef-f0adb0a70417","draft":false,"unlisted":false,"editUrl":"https://github.com/emmableu/notes/edit/main/docs/Leetcode/99.Other/973.973 - K Closest Points to Origin - Medium.md","tags":[],"version":"current","frontMatter":{"created_at":"2025-10-23","page_link":"/p/5e39533c-1dcd-4c36-85ef-f0adb0a70417","slug":"/p/5e39533c-1dcd-4c36-85ef-f0adb0a70417"},"sidebar":"tutorialSidebar","previous":{"title":"958.958 - Check Completeness of a Binary Tree (Medium)","permalink":"/notes/docs/p/978f9d5d-8e1b-4cfd-b87d-547dc4ca87c9"},"next":{"title":"977.977 - Squares of a Sorted Array - Easy","permalink":"/notes/docs/p/3bb4048a-b246-4515-bf8c-5892bdfb4039"}}');var s=i(74848),r=i(28453);const o={created_at:"2025-10-23",page_link:"/p/5e39533c-1dcd-4c36-85ef-f0adb0a70417",slug:"/p/5e39533c-1dcd-4c36-85ef-f0adb0a70417"},l=void 0,a={},c=[{value:"solution 1: quick select (preferred)",id:"solution-1-quick-select-preferred",level:2},{value:"code",id:"code",level:3},{value:"\u65f6\u95f4\u590d\u6742\u5ea6\u5206\u6790",id:"\u65f6\u95f4\u590d\u6742\u5ea6\u5206\u6790",level:3},{value:"\u4e3a\u4ec0\u4e48\u4e0d\u662f n log n",id:"\u4e3a\u4ec0\u4e48\u4e0d\u662f-n-log-n",level:4},{value:"solution 2: max-heap",id:"solution-2-max-heap",level:2}];function d(e){const n={a:"a",br:"br",code:"code",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.img,{src:"https://raw.githubusercontent.com/emmableu/image/master/202208301816702.png",alt:""}),"\n",(0,s.jsx)(n.img,{src:"https://raw.githubusercontent.com/emmableu/image/master/202208301816106.png",alt:""})]}),"\n",(0,s.jsx)(n.h2,{id:"solution-1-quick-select-preferred",children:"solution 1: quick select (preferred)"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\u5148\u5efa\u7acb\u8ddd\u79bb dist \u6570\u7ec4\uff1a e.g. ",(0,s.jsx)(n.code,{children:"points = [[3,3],[5,-1],[-2,4]]"})," , then ",(0,s.jsx)(n.code,{children:"dist = [18, 26, 20]"})," \u5bf9\u8fd9\u4e2a\u505aquick select"]}),"\n",(0,s.jsx)(n.li,{children:"\u6bcf\u6b21 \u8fd4\u56de marker\u7684index\uff0cmarker\u7684\u5de6\u8fb9\u90fd\u5c0f\u4e8emarker\u3002\u5982\u679c \u5c0f\u4e8ek\u4e2a\uff0c\u90a3\u5c31\u628al\u653e\u5728marker+1\uff0c\u5982\u679c\u5927\u4e8ek\u4e2a\uff0c\u5c31\u628ar\u653e\u5728marker-1, \u5982\u679c\u7b49\u4e8ek\u4e2a\uff0c\u5c31\u8fd4\u56de\u3002"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"quick select \u6a21\u7248\u89c1"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/pages/5d7c1e/#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-quick-sort-%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86",children:"quick sort \u6a21\u7248"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/pages/leetcode215/",children:"297 - 215 - Kth Largest Element in an Array"})}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"code",children:"code"}),"\n",(0,s.jsxs)(n.p,{children:["\u6ce8\u610f\uff1amid \u4e0d\u80fd\u9009\u5728 = k (i.e., \u6700\u540e\u51fa\u6765 ",(0,s.jsx)(n.code,{children:"points[:mid]"}),"), \u56e0\u4e3a\u8fd9\u6837\u7684\u8bdd mid\u53ef\u80fd\u4f1a\u51fa\u754c \uff08e.g.\uff0c \u603b\u5171\u53ea\u6709\u4e24\u4e2a\u5143\u7d20\uff0c\u53d6\u524d2\u4e2a\u7684\u65f6\u5019\uff09\u3002"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import random\n\n\nclass Solution:\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\n        for i, (x, y) in enumerate(points):\n            points[i] = [x * x + y * y, x, y]\n        self.shuffle(points)\n        mid = self.quick_select(points, k, 0, len(points) - 1)\n        return [ele[1:] for ele in points[:mid + 1]]\n\n    def shuffle(self, nums):\n        for i in range(len(nums)):\n            swap_idx = random.randint(i, len(nums) - 1)\n            if swap_idx != i:\n                nums[i], nums[swap_idx] = nums[swap_idx], nums[i]\n\n    def partition(self, nums, l, r):\n        pivot_val = nums[r]\n        marker = l\n        for i in range(l, r):\n            if nums[i] < pivot_val:\n                nums[i], nums[marker] = nums[marker], nums[i]\n                marker += 1\n        nums[marker], nums[r] = nums[r], nums[marker]\n        return marker\n\n    def quick_select(self, nums, k, l, r):\n        mid = self.partition(nums, l, r)\n        if mid == k - 1:  # we want from [0, mid], including mid\n            return mid\n        if mid < k - 1:\n            return self.quick_select(nums, k, mid + 1, r)\n        if mid > k - 1:\n            return self.quick_select(nums, k, l, mid - 1)\t\t\n"})}),"\n",(0,s.jsx)(n.h3,{id:"\u65f6\u95f4\u590d\u6742\u5ea6\u5206\u6790",children:"\u65f6\u95f4\u590d\u6742\u5ea6\u5206\u6790"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["time complexity:\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"avg time complexity: O(n)"}),"\n",(0,s.jsx)(n.li,{children:"worst case time complexity: O(n^2)"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"\u4e3a\u4ec0\u4e48\u4e0d\u662f-n-log-n",children:"\u4e3a\u4ec0\u4e48\u4e0d\u662f n log n"}),"\n",(0,s.jsxs)(n.p,{children:["(",(0,s.jsx)(n.a,{href:"https://stackoverflow.com/questions/56940793/quickselect-time-complexity-explained",children:"\u6765\u81eastackoverflow"}),")",(0,s.jsx)(n.br,{}),"\nn log(n) implies that the algorithm looks at all N items log(n) times. But that's not what's happening with Quickselect."]}),"\n",(0,s.jsx)(n.p,{children:"Let's say you're using Quickselect to pick the top 8 items in a list of 128. And by some miracle of random selection, the pivots you pick are always at the halfway point."}),"\n",(0,s.jsx)(n.p,{children:"On the first iteration, the algorithm looks at all 128 items and partitions into two groups of 64 items each. The next iteration splits into two groups of 32 items each. Then 16, and then 8. The number of items examined is:"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"N + N/2 + N/4 + N/8 + N/16"}),(0,s.jsx)(n.br,{}),"\nThe sum of that series will never reach ",(0,s.jsx)(n.code,{children:"2*N"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"The worst case is that partitioning always results in very skewed partition sizes. Consider what would happen if the first partitioning only removed one item. And the second only removed one, etc. The result would be:"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"N + (N-1) + (N-2) ..."}),(0,s.jsx)(n.br,{}),"\nWhich is (n^2 + n)/2), or ",(0,s.jsx)(n.code,{children:"O(n^2)"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"solution-2-max-heap",children:"solution 2: max-heap"}),"\n",(0,s.jsx)(n.p,{children:"\u4fdd\u6301\u4e00\u4e2asize \u4e3a k \u7684maxheap\uff0c\u5f53\u6709\u65b0\u7684point\u8fdb\u53bb\u7684\u65f6\u5019\uff0c \u5982\u679csize >k, pop its top element. \u6700\u540e\u5f53\u6240\u6709point\u90fditerate\u4e00\u904d\u4ee5\u540e, \u76f4\u63a5 return \u8fd9\u4e2asize\u4e3ak\u7684maxheap (O(n lg k + k)) (the last return statement costs k time complexity)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import heapq\nclass Solution:\n    def kClosest(self, points, k):\n        h = []\n        for p in points:\n            sqdist = - (p[0]*p[0] + p[1]*p[1])\n            #sqdist need to use negative. since in python heaps are minheap by default\n            heapq.heappush(h, (sqdist, p)) \n            #keep in mind that the first argument for heappush is the heap itself\n            if len(h) == k+1:\n                heapq.heappop(h)\n                # keep in mind that heappop should be called by heapq (not h)\n        return [ele[1] for ele in h]    \n"})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);