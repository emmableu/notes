"use strict";(globalThis.webpackChunknotes=globalThis.webpackChunknotes||[]).push([[19405],{28453:(e,t,n)=>{n.d(t,{R:()=>c,x:()=>o});var s=n(96540);const i={},r=s.createContext(i);function c(e){const t=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),s.createElement(r.Provider,{value:t},e.children)}},86476:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>o,default:()=>u,frontMatter:()=>c,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"Leetcode/Other/161.161 - One Edit Distance - Medium","title":"161.161 - One Edit Distance - Medium","description":"Description","source":"@site/docs/03. Leetcode/99.Other/161.161 - One Edit Distance - Medium.md","sourceDirName":"03. Leetcode/99.Other","slug":"/p/61575d0e-c96b-430e-b68d-693e531bcbc7","permalink":"/notes/docs/p/61575d0e-c96b-430e-b68d-693e531bcbc7","draft":false,"unlisted":false,"editUrl":"https://github.com/emmableu/notes/edit/main/docs/03. Leetcode/99.Other/161.161 - One Edit Distance - Medium.md","tags":[],"version":"current","frontMatter":{"created_at":"2025-10-23","page_link":"/p/61575d0e-c96b-430e-b68d-693e531bcbc7","slug":"/p/61575d0e-c96b-430e-b68d-693e531bcbc7"},"sidebar":"tutorialSidebar","previous":{"title":"16.16 - 3Sum Closest - Medium","permalink":"/notes/docs/p/76a39b67-bc64-4b53-9119-f08fca0d154b"},"next":{"title":"1614.1614 - Maximum Nesting Depth of the Parentheses (Easy)","permalink":"/notes/docs/p/44209d4c-2d4a-4590-9de8-eb4f99f7e1a1"}}');var i=n(74848),r=n(28453);const c={created_at:"2025-10-23",page_link:"/p/61575d0e-c96b-430e-b68d-693e531bcbc7",slug:"/p/61575d0e-c96b-430e-b68d-693e531bcbc7"},o=void 0,a={},d=[{value:"Description",id:"description",level:2},{value:"Examples",id:"examples",level:2},{value:"Solution",id:"solution",level:2}];function l(e){const t={code:"code",h2:"h2",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h2,{id:"description",children:"Description"}),"\n",(0,i.jsx)(t.p,{children:"Given two strings s and t, return true if they are both one edit distance apart, otherwise return false."}),"\n",(0,i.jsx)(t.p,{children:"A string s is said to be one distance apart from a string t if you can:"}),"\n",(0,i.jsx)(t.p,{children:"Insert exactly one character into s to get t.\nDelete exactly one character from s to get t.\nReplace exactly one character of s with a different character to get t."}),"\n",(0,i.jsx)(t.h2,{id:"examples",children:"Examples"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'Example 1:\nInput: s = "ab", t = "acb"\nOutput: true\nExplanation: We can insert \'c\' into s to get t.\n\nExample 2:\nInput: s = "", t = ""\nOutput: false\nExplanation: We cannot get t from s by only one step.\n\nExample 3:\nInput: s = "a", t = ""\nOutput: true\n\nExample 4:\nInput: s = "", t = "A"\nOutput: true\n'})}),"\n",(0,i.jsx)(t.h2,{id:"solution",children:"Solution"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-python",children:"class Solution:\n    def isOneEditDistance(self, s, t):\n        if len(s) > len(t):\n            return self.isOneEditDistance(t, s)\n        if len(t) - len(s) > 1 or s == t:\n            return False\n        for i in range(len(s)):\n            if s[i] != t[i]:\n                return s[i+1:] == t[i+1:] or s[i:] == t[i+1:]\n        return True\n"})})]})}function u(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}}}]);