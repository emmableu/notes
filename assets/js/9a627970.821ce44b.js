"use strict";(globalThis.webpackChunknotes=globalThis.webpackChunknotes||[]).push([[30592],{28453:(e,t,a)=>{a.d(t,{R:()=>s,x:()=>i});var n=a(96540);const r={},o=n.createContext(r);function s(e){const t=n.useContext(o);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),n.createElement(o.Provider,{value:t},e.children)}},99322:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>i,default:()=>p,frontMatter:()=>s,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"Leetcode/Other/104.104 - Maximum Depth of Binary Tree - Easy","title":"104.104 - Maximum Depth of Binary Tree - Easy","description":"tags: [Tree, Depth-First Search, Breadth-First Search, Binary Tree]","source":"@site/docs/03. Leetcode/99.Other/104.104 - Maximum Depth of Binary Tree - Easy.md","sourceDirName":"03. Leetcode/99.Other","slug":"/p/bb16829a-da59-43c0-bfea-42da1b60d9de","permalink":"/notes/docs/p/bb16829a-da59-43c0-bfea-42da1b60d9de","draft":false,"unlisted":false,"editUrl":"https://github.com/emmableu/notes/edit/main/docs/03. Leetcode/99.Other/104.104 - Maximum Depth of Binary Tree - Easy.md","tags":[],"version":"current","frontMatter":{"created_at":"2025-10-23","page_link":"/p/bb16829a-da59-43c0-bfea-42da1b60d9de","slug":"/p/bb16829a-da59-43c0-bfea-42da1b60d9de"},"sidebar":"tutorialSidebar","previous":{"title":"1027.1027 - Longest Arithmetic Subsequence (Medium)","permalink":"/notes/docs/p/1dc5bd04-4725-434f-ba85-7c84295f23ae"},"next":{"title":"1041.1041 - Robot Bounced In Circle","permalink":"/notes/docs/p/53c39011-48f6-4d56-b580-8bcf3c7ed3d8"}}');var r=a(74848),o=a(28453);const s={created_at:"2025-10-23",page_link:"/p/bb16829a-da59-43c0-bfea-42da1b60d9de",slug:"/p/bb16829a-da59-43c0-bfea-42da1b60d9de"},i=void 0,d={},c=[];function l(e){const t={a:"a",code:"code",img:"img",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.p,{children:"tags: [Tree, Depth-First Search, Breadth-First Search, Binary Tree]"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.a,{href:"https://leetcode.cn/problems/maximum-depth-of-binary-tree/",children:"LC Link"}),"\n",(0,r.jsx)(t.img,{width:"793",alt:"image",src:"https://user-images.githubusercontent.com/41789327/178158511-bfe5e6d7-1ca3-4acc-b9fe-17b0d904e2a2.png"}),"\n",(0,r.jsx)(t.a,{href:"https://labuladong.gitee.io/algo/2/20/35/",children:"labuladong \u8bb2\u89e3"})]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        left_max = self.maxDepth(root.left)\n        right_max = self.maxDepth(root.right)\n        max_depth = max(left_max, right_max) + 1\n        return max_depth\n"})})]})}function p(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}}}]);