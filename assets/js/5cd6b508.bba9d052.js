"use strict";(self.webpackChunknotes=self.webpackChunknotes||[]).push([[7790],{21728:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"Leetcode/DFS/DFS - Graph DFS \u6a21\u7248","title":"DFS - Graph DFS \u6a21\u7248","description":"0. Graph Representation","source":"@site/docs/Leetcode/04.DFS/07. DFS - Graph DFS \u6a21\u7248.md","sourceDirName":"Leetcode/04.DFS","slug":"/p/970d768e-4d52-4054-a130-3e46dcf37188","permalink":"/notes/docs/p/970d768e-4d52-4054-a130-3e46dcf37188","draft":false,"unlisted":false,"editUrl":"https://github.com/emmableu/notes/edit/main/docs/Leetcode/04.DFS/07. DFS - Graph DFS \u6a21\u7248.md","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"created_at":"2025-10-23","page_link":"/p/970d768e-4d52-4054-a130-3e46dcf37188","slug":"/p/970d768e-4d52-4054-a130-3e46dcf37188"},"sidebar":"tutorialSidebar","previous":{"title":"DFS - Backtracking \u6a21\u7248","permalink":"/notes/docs/p/a98e4af7-a3ea-446d-b330-fefde19c0fa1"},"next":{"title":"DFS - Grid DFS - \u5c9b\u5c7f\u95ee\u9898 - \u7f51\u683cdfs - grid dfs","permalink":"/notes/docs/p/b5997b8e-6dff-4459-877c-9c7632192729"}}');var s=t(74848),i=t(28453);const o={created_at:"2025-10-23",page_link:"/p/970d768e-4d52-4054-a130-3e46dcf37188",slug:"/p/970d768e-4d52-4054-a130-3e46dcf37188"},a=void 0,d={},l=[{value:"0. Graph Representation",id:"0-graph-representation",level:2},{value:"1. Basic Template",id:"1-basic-template",level:2},{value:"Example 1: DAG: 797 - All Paths From Source to Target",id:"example-1-dag-797---all-paths-from-source-to-target",level:2},{value:"Connected Undirected Graph  - 133 - Clone Graph",id:"connected-undirected-graph----133---clone-graph",level:2},{value:"Solution: DFS",id:"solution-dfs",level:2},{value:"Solution",id:"solution",level:3},{value:"Example 3: Determine for Directed Acyclic Graph (Topological Sort - DFS implementation)",id:"example-3-determine-for-directed-acyclic-graph-topological-sort---dfs-implementation",level:2},{value:"i.e., 210. Course Schedule II",id:"ie-210-course-schedule-ii",level:2},{value:"Examples",id:"examples",level:2},{value:"Solution 1 - DFS",id:"solution-1---dfs",level:2}];function c(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"0-graph-representation",children:"0. Graph Representation"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:"https://raw.githubusercontent.com/emmableu/image/master/202506050327807.png",alt:""})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"**Input:** graph = [[4,3,1],[3,2,4],[3],[4],[]]\n"})}),"\n",(0,s.jsx)(n.h2,{id:"1-basic-template",children:"1. Basic Template"}),"\n",(0,s.jsxs)(n.p,{children:["only thing different from tree DFS is that we add ",(0,s.jsx)(n.code,{children:"visited"})," here.  \u7528visited\u6765\u9632\u6b62\u73af"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def traverse(node: int, graph: List[List], visited: Set):\n\tif node is None: # edge case, may not be needed\n\t\treturn\n\tif node in visited: # this is the additional on top of tree traverse, prevent cycles \u9632\u6b62\u73af\n\t\treturn\n\tvisited.add(node)\n\t# \u524d\u5e8f\u4f4d\u7f6e\n\tfor child in graph[node]:\n\t\ttraverse(child, graph, visited)\n\t# \u540e\u5e8f\u4f4d\u7f6e\n"})}),"\n",(0,s.jsx)(n.h2,{id:"example-1-dag-797---all-paths-from-source-to-target",children:"Example 1: DAG: 797 - All Paths From Source to Target"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.img,{src:"https://raw.githubusercontent.com/emmableu/image/master/202506050317596.png",alt:""}),"\n",(0,s.jsx)(n.img,{src:"https://raw.githubusercontent.com/emmableu/image/master/202506050318448.png",alt:""})]}),"\n",(0,s.jsx)(n.p,{children:"because there's no cycle, we don't need visited"}),"\n",(0,s.jsxs)(n.p,{children:["question to ",(0,s.jsx)(n.em,{children:"think"})," before implementation: shoud cur_path start as ",(0,s.jsx)(n.code,{children:"[0]"})," or ",(0,s.jsx)(n.code,{children:"[]"}),"?"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"class Solution:\n\tdef allPathsSourceTarget(self, graph: List[List[int]]) -> List[List[int]]:\n\t\tres = []\n\t\tself.dfs(0, [0], res, graph)\n\t\treturn res\n\t\t\n\tdef dfs(self, node, cur_path, res, graph):\n\t\tif node == len(graph) - 1:\n\t\t\tres.append(cur_path)\n\n\t\tfor child in graph[node]:\n\t\t\tself.dfs(child, cur_path + [child], res, graph)\n"})}),"\n",(0,s.jsx)(n.h2,{id:"connected-undirected-graph----133---clone-graph",children:"Connected Undirected Graph  - 133 - Clone Graph"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/clone-graph/",children:"LC link"}),"\n",(0,s.jsx)(n.a,{href:"https://leetcode-cn.com/problems/clone-graph/solution/dfs-he-bfs-by-powcai/",children:"very brief explanation"})]}),"\n",(0,s.jsx)(n.p,{children:"\u7c7b\u4f3c\u9898\uff1a"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/pages/891221/",children:"delete node and return forest"})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.img,{src:"https://raw.githubusercontent.com/emmableu/image/master/133-0.png",alt:""}),"\n",(0,s.jsx)(n.img,{src:"https://raw.githubusercontent.com/emmableu/image/master/133-1.png",alt:""}),"\n",(0,s.jsx)(n.img,{src:"https://raw.githubusercontent.com/emmableu/image/master/133-2.png",alt:""})]}),"\n",(0,s.jsx)(n.h2,{id:"solution-dfs",children:"Solution: DFS"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"1 - 2 - 3 - 4\n -----------\n\n\u5982\u679c\u662f\u6811\uff0c\u53ef\u4ee5\u76f4\u63a5copy\n\u56fe\u7684challenge\uff1a \u6709\u73af\n\n\u5904\u7406\u73af\u7684trick: visited use a dict, visited[old_node] = new_node\n\n\u7136\u540e visited[old_node(1)] \u8fdb\u53bb\u7684\u65f6\u5019\u53ea\u662f\u5355\u4e2a\u76841\uff0c\u6ca1\u6709children\n4\u7684neighbor\u9047\u52301\uff0c \u8fd4\u56de\u90a3\u4e2a\u5355\u4e2a\u7684node\n\n\u7136\u540e\u6700\u540e\u9010\u6b65\u8fd4\u56de\u540e\uff0c\u8fd9\u4e2a\u5355\u4e2a\u7684node\u7684object\u4f1a\u88abpopulate\n\u6240\u4ee5\u6700\u540e\u8fd9\u4e2a\u4f1aimplicitely\u7684update\n"})}),"\n",(0,s.jsx)(n.h3,{id:"solution",children:"Solution"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'"""\n# Definition for a Node.\nclass Node:\n    def __init__(self, val = 0, neighbors = None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n"""\nclass Solution:\n\tdef cloneGraph(self, node):\n\t\tif node is None:\n\t\t\treturn None\n\t\treturn self.dfs(node, {})\n\tdef dfs(self, node, visited):\n\t\tif node in visited:\n\t\t\treturn visited[node]\n\t\tnew = Node(node.val)\n\t\tvisited[node] = new\n\t\tnew_neighbors = []\n\t\tfor neighbor in node.neighbors:\n\t\t\tnew_neighbors.append(self.dfs(neighbor, visited))\n\t\tnew.neighbors = new_neighbors\n\t\treturn new\n'})}),"\n",(0,s.jsx)(n.h2,{id:"example-3-determine-for-directed-acyclic-graph-topological-sort---dfs-implementation",children:"Example 3: Determine for Directed Acyclic Graph (Topological Sort - DFS implementation)"}),"\n",(0,s.jsx)(n.h2,{id:"ie-210-course-schedule-ii",children:"i.e., 210. Course Schedule II"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://leetcode.com/problems/course-schedule-ii/",children:"LC link"}),"\n",(0,s.jsx)(n.a,{href:"http://zxi.mytechroad.com/blog/graph/leetcode-210-course-schedule-ii/",children:"explanation"}),"\nThere are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai."]}),"\n",(0,s.jsx)(n.p,{children:"For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1."}),"\n",(0,s.jsx)(n.p,{children:"Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array."}),"\n",(0,s.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Example 1:\nInput: numCourses = 2, prerequisites = [[1,0]]\nOutput: [0,1]\nExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].\n\nExample 2:\nInput: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\nOutput: [0,2,1,3]\nExplanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.\nSo one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].\n\nExample 3:\nInput: numCourses = 1, prerequisites = []\nOutput: [0]\n"})}),"\n",(0,s.jsx)(n.h2,{id:"solution-1---dfs",children:"Solution 1 - DFS"}),"\n",(0,s.jsx)(n.p,{children:"will reverse it afterwards. but taking it forward direction for now:"}),"\n",(0,s.jsx)(n.p,{children:"understanding it as a tree problem"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"0 -> 1\n     |/\n  -> 2\n\ninput: [[1,2], [2], []]\nreturns [0, 1, 2]\ncall graph:\n\t\t\t0   1(cut)   2(cut)\n\t\t  /  \\\n\t\t1     2\n\t  /\n\t2\n----------------------------------------------\n0 -> 1\n     \n     2\ninput [[1], [], []]\nreturns [0, 1, 2]\n\n\t\t   0   1(cut)   2(keep)\n\t\t  /\n\t\t1\n--------------------------------------------------\n\n  0 -> 1\n /|    |/\n    2\ninput [[1], [2], [0]]\nreturns []\n\n\t\t\t0   1...(returns before get here)   2...(returns before get here)\n\t\t  /\n\t\t1\n\t  /\n\t2\n   /\n  0\n...\n----------------------------------------------------\n\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"need to detect cycle using cur_path_set, and save visited in a set"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"unlike cur_path in trees, this cur_path_set does not include the cur_idx, as this is to detect cycles"}),"\n",(0,s.jsx)(n.li,{children:"unlike standard graph dfs, here we mark visited at post-order position, this is because if we mark visited during pre-order, than what's supposed to be a cycle will also be marked as visited."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"from collections import defaultdict\nclass Solution:\n    def findOrder(self, numCourses, prerequisites):\n        res = []\n        visited = set()\n        graph = self.build_graph(prerequisites)\n        for i in range(numCourses):\n            is_dag = self.dfs(i, set(), visited, res, graph)\n            if not is_dag:\n                return []\n        return res\n\n    def build_graph(self, prerequisites):\n        graph = defaultdict(list)\n        for i, j in prerequisites:\n            graph[i].append(j)\n        return graph\n\n    def dfs(self, cur_idx, cur_path_set, visited, res, graph):\n        if cur_idx in visited: # cut\n            return True\n        if cur_idx in cur_path_set: # need to first check this\n            return False\n        for neighbor in graph[cur_idx]:\n            is_dag = self.dfs(neighbor, cur_path_set | {cur_idx}, visited, res, graph)\n            if not is_dag:\n                return False\n        res.append(cur_idx)\n        visited.add(cur_idx) # unlke typical graph dfs, here we put visited at post-order position, as otherwise, a cyce will be first checked as visited as well and be regarded as valid. \n        return True\n        \n"})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var r=t(96540);const s={},i=r.createContext(s);function o(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);