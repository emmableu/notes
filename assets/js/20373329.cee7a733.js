"use strict";(self.webpackChunknotes=self.webpackChunknotes||[]).push([[4326],{28453:(n,e,r)=>{r.d(e,{R:()=>d,x:()=>o});var i=r(96540);const s={},t=i.createContext(s);function d(n){const e=i.useContext(t);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:d(n.components),i.createElement(t.Provider,{value:e},n.children)}},80793:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>f,frontMatter:()=>d,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"Leetcode/DFS/200.200 - Number of Islands - Medium","title":"200.200 - Number of Islands - Medium","description":"Description:","source":"@site/docs/Leetcode/04.DFS/200.200 - Number of Islands - Medium.md","sourceDirName":"Leetcode/04.DFS","slug":"/p/06bc8603-625b-4483-b3f7-b64b421d6acf","permalink":"/notes/docs/p/06bc8603-625b-4483-b3f7-b64b421d6acf","draft":false,"unlisted":false,"editUrl":"https://github.com/emmableu/notes/edit/main/docs/Leetcode/04.DFS/200.200 - Number of Islands - Medium.md","tags":[],"version":"current","frontMatter":{"created_at":"2025-10-23","page_link":"/p/06bc8603-625b-4483-b3f7-b64b421d6acf","slug":"/p/06bc8603-625b-4483-b3f7-b64b421d6acf"},"sidebar":"tutorialSidebar","previous":{"title":"1820.1820 - Maximum Number of Accepted Invitations - Medium","permalink":"/notes/docs/p/aa909471-863b-4874-b26a-e2b254699551"},"next":{"title":"2096.2096 - Step-By-Step Directions From a Binary Tree Node to Another - Medium","permalink":"/notes/docs/p/233ccf9d-71c9-4478-8c0b-122f47fe7ed9"}}');var s=r(74848),t=r(28453);const d={created_at:"2025-10-23",page_link:"/p/06bc8603-625b-4483-b3f7-b64b421d6acf",slug:"/p/06bc8603-625b-4483-b3f7-b64b421d6acf"},o=void 0,l={},c=[{value:"Description:",id:"description",level:2},{value:"Examples",id:"examples",level:2},{value:"\u5c9b\u5c7f\u95ee\u9898dfs\u6a21\u7248:",id:"\u5c9b\u5c7f\u95ee\u9898dfs\u6a21\u7248",level:2},{value:"DFS",id:"dfs",level:2},{value:"Union Find",id:"union-find",level:2}];function a(n){const e={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",...(0,t.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.h2,{id:"description",children:"Description:"}),"\n",(0,s.jsx)(e.p,{children:"Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands."}),"\n",(0,s.jsx)(e.p,{children:"An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water."}),"\n",(0,s.jsx)(e.h2,{id:"examples",children:"Examples"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:'Example 1:\n\nInput: grid = [\n  ["1","1","1","1","0"],\n  ["1","1","0","1","0"],\n  ["1","1","0","0","0"],\n  ["0","0","0","0","0"]\n]\nOutput: 1\nExample 2:\n\nInput: grid = [\n  ["1","1","0","0","0"],\n  ["1","1","0","0","0"],\n  ["0","0","1","0","0"],\n  ["0","0","0","1","1"]\n]\nOutput: 3\n'})}),"\n",(0,s.jsx)(e.h2,{id:"\u5c9b\u5c7f\u95ee\u9898dfs\u6a21\u7248",children:"\u5c9b\u5c7f\u95ee\u9898dfs\u6a21\u7248:"}),"\n",(0,s.jsxs)(e.p,{children:["\u53c2\u8003\uff08",(0,s.jsx)(e.a,{href:"https://leetcode-cn.com/problems/number-of-islands/solution/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/%EF%BC%89",children:"https://leetcode-cn.com/problems/number-of-islands/solution/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/\uff09"})]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'class Solution:\n    def func(self, grid: List[List[str]]) -> int:\n        # \u9898\u76ee\u8981\u6c42\u7684function\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if grid[r][c] == "1":\n                    # \u9898\u76ee\u8981\u6c42\u7684\u4e1c\u897f\n                    self.dfs(grid, r, c)\n        return #\u9898\u76ee\u8981\u6c42\u7684function\n        \n    def dfs(self, grid, r, c):\n        # base case\uff1a\u5982\u679c\u5750\u6807\u8d85\u51fa\u7f51\u683c\uff0c\u76f4\u63a5\u8fd4\u56de\n        if not self.in_area(grid, r, c):\n            return\n        if grid[r][c] != "1":\n            return \n        grid[r][c] = "2" #\u6807\u8bb0\u4ee5\u9632\u6b62\u91cd\u590dvisit\n        self.dfs(grid, r-1, c)\n        self.dfs(grid, r+1, c)\n        self.dfs(grid, r, c-1)\n        self.dfs(grid, r, c+1)\n        \n    def in_area(self, grid, r, c):\n        return r >= 0 and r < len(grid) and c >= 0 and c < len(grid[0])\n'})}),"\n",(0,s.jsx)(e.h2,{id:"dfs",children:"DFS"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'class Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n        visited = [[False for j in range(len(grid[0]))] for i in range(len(grid))]\n        res = 0\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if grid[r][c] == "1" and visited[r][c] == False:\n                    self.dfs(r, c, grid, visited)\n                    res += 1\n        return res\n            \n        \n    def dfs(self, r, c, grid, visited):\n        if not self.in_area(r, c, grid):\n            return\n        if grid[r][c] != "1":\n            return\n        if visited[r][c]: # put in preorder to prevent cycle\n            return\n        visited[r][c] = True\n        for i, j in [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]:\n            self.dfs(i, j, grid, visited)\n\n    def in_area(self, r, c, grid):\n        return 0<=r<len(grid) and 0 <= c < len(grid[0])       \n'})}),"\n",(0,s.jsx)(e.h2,{id:"union-find",children:"Union Find"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"class UF:\n    def __init__(self, n, cnt):\n        self.cnt = cnt\n        self.parent = [i for i in range(n)]\n        self.rank = [1] * n\n\n    def find(self, x):\n        if x != self.parent[x]:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, p, q):\n        rootp = self.find(p)\n        rootq = self.find(q)\n        if rootp == rootq:\n            return\n        if self.rank[rootq] < self.rank[rootq]:\n            rootp, rootq = rootq, rootp\n        self.parent[rootp] = rootq\n        self.rank[rootq] += self.rank[rootp]\n        self.cnt -= 1\n\n    def connected(self, p, q):\n        rootp = self.find(p)\n        rootq = self.find(q)\n        return rootp == rootq\n\nclass Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n        m, n = len(grid), len(grid[0])\n        num_1 = 0\n        for r in range(m):\n            for c in range(n):\n                 if grid[r][c] == '1':\n                    num_1 += 1\t\t \n        uf = UF(m * n + 1, num_1)\n        for r in range(m):\n            for c in range(n):\n                if grid[r][c] == '1':\n                    for x, y in (r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1):\n                        if 0 <= x < m and 0 <= y < n and grid[x][y] == '1':\n                            uf.union(r * n + c, x * n + y)\n        return uf.cnt\n"})})]})}function f(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(a,{...n})}):a(n)}}}]);