"use strict";(self.webpackChunknotes=self.webpackChunknotes||[]).push([[5849],{28453:(e,r,t)=>{t.d(r,{R:()=>i,x:()=>l});var n=t(96540);const o={},s=n.createContext(o);function i(e){const r=n.useContext(s);return n.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function l(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),n.createElement(s.Provider,{value:r},e.children)}},41138:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>a,contentTitle:()=>l,default:()=>u,frontMatter:()=>i,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"Leetcode/Other/145.145 - Binary Tree Postorder Traversal","title":"145.145 - Binary Tree Postorder Traversal","description":"Description:","source":"@site/docs/Leetcode/99.Other/145.145 - Binary Tree Postorder Traversal.md","sourceDirName":"Leetcode/99.Other","slug":"/p/14514f2b-e352-4322-b2fd-92ec95188c56","permalink":"/notes/docs/p/14514f2b-e352-4322-b2fd-92ec95188c56","draft":false,"unlisted":false,"editUrl":"https://github.com/emmableu/notes/edit/main/docs/Leetcode/99.Other/145.145 - Binary Tree Postorder Traversal.md","tags":[],"version":"current","frontMatter":{"created_at":"2025-10-23","page_link":"/p/14514f2b-e352-4322-b2fd-92ec95188c56","slug":"/p/14514f2b-e352-4322-b2fd-92ec95188c56"},"sidebar":"tutorialSidebar","previous":{"title":"144.144 - Binary Tree Preorder Traversal - Easy","permalink":"/notes/docs/p/4cbd6c3d-926b-4ea3-93b2-7edd075e254d"},"next":{"title":"146.146 - LRU Cache - Medium","permalink":"/notes/docs/p/abc7a83f-7200-4c7f-a23e-ff491c8b4206"}}');var o=t(74848),s=t(28453);const i={created_at:"2025-10-23",page_link:"/p/14514f2b-e352-4322-b2fd-92ec95188c56",slug:"/p/14514f2b-e352-4322-b2fd-92ec95188c56"},l=void 0,a={},c=[{value:"Description:",id:"description",level:2},{value:"Examples",id:"examples",level:2},{value:"Recursive solution:",id:"recursive-solution",level:2},{value:"Iterative solution",id:"iterative-solution",level:2},{value:"Method 1",id:"method-1",level:3}];function d(e){const r={code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(r.h2,{id:"description",children:"Description:"}),"\n",(0,o.jsx)(r.p,{children:"Given the root of a binary tree, return the postorder traversal of its nodes' values."}),"\n",(0,o.jsx)(r.h2,{id:"examples",children:"Examples"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{children:"Input: root = [1,null,2,3]\nOutput: [3,2,1]\n"})}),"\n",(0,o.jsx)(r.h2,{id:"recursive-solution",children:"Recursive solution:"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-python",children:"class Solution:\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        if not root:\n            return []\n        left = self.postorderTraversal(root.left)\n        right = self.postorderTraversal(root.right)\n        return  left + right + [root.val] \n"})}),"\n",(0,o.jsx)(r.h2,{id:"iterative-solution",children:"Iterative solution"}),"\n",(0,o.jsx)(r.h3,{id:"method-1",children:"Method 1"}),"\n",(0,o.jsx)(r.p,{children:"preorder \u53cd\u8fc7\u6765\u3002"}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-python",children:"class Solution(object):\n    def postorderTraversal(self, root):\n        if not root:\n            return []\n        reversed_res = []\n        s = [root]\n        while s:\n            curr = s.pop()\n            reversed_res.append(curr.val)\n            if curr.left:\n                s.append(curr.left)\n            if curr.right:\n                s.append(curr.right)\n        return reversed_res[::-1]    \n"})})]})}function u(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,o.jsx)(r,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);