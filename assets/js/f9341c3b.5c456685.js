"use strict";(self.webpackChunknotes=self.webpackChunknotes||[]).push([[6898],{15478:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>o,default:()=>l,frontMatter:()=>i,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"Leetcode/DFS/416.416 - Partition Equal Subset Sum (Medium)","title":"416.416 - Partition Equal Subset Sum (Medium)","description":"Description:","source":"@site/docs/Leetcode/04.DFS/416.416 - Partition Equal Subset Sum (Medium).md","sourceDirName":"Leetcode/04.DFS","slug":"/p/d4b1742a-b67c-4693-a34d-f0e40b0060c2","permalink":"/notes/docs/p/d4b1742a-b67c-4693-a34d-f0e40b0060c2","draft":false,"unlisted":false,"editUrl":"https://github.com/emmableu/notes/edit/main/docs/Leetcode/04.DFS/416.416 - Partition Equal Subset Sum (Medium).md","tags":[],"version":"current","frontMatter":{"created_at":"2025-10-23","page_link":"/p/d4b1742a-b67c-4693-a34d-f0e40b0060c2","slug":"/p/d4b1742a-b67c-4693-a34d-f0e40b0060c2"},"sidebar":"tutorialSidebar","previous":{"title":"366.366 - Find Leaves of Binary Tree - Medium","permalink":"/notes/docs/p/5da9e8dc-b11e-4168-b956-2d78c6630d5c"},"next":{"title":"425.425 - Word Squares - Hard","permalink":"/notes/docs/p/f578589b-3465-4827-9da1-666fcec22135"}}');var s=t(74848),a=t(28453);const i={created_at:"2025-10-23",page_link:"/p/d4b1742a-b67c-4693-a34d-f0e40b0060c2",slug:"/p/d4b1742a-b67c-4693-a34d-f0e40b0060c2"},o=void 0,u={},d=[{value:"Description:",id:"description",level:2},{value:"Examples",id:"examples",level:2},{value:"Methods",id:"methods",level:2},{value:"Implementations",id:"implementations",level:2},{value:"Method 1: brute-force recursion",id:"method-1-brute-force-recursion",level:3},{value:"Method 2: memoization",id:"method-2-memoization",level:3}];function c(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"description",children:"Description:"}),"\n",(0,s.jsx)(n.p,{children:"Given a non-empty array nums containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal."}),"\n",(0,s.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"Example 1:\n\nInput: nums = [1,5,11,5]\nOutput: true\nExplanation: The array can be partitioned as [1, 5, 5] and [11].\n\nExample 2:\n\nInput: nums = [1,2,3,5]\nOutput: false\nExplanation: The array cannot be partitioned into equal sum subsets.\n"})}),"\n",(0,s.jsx)(n.h2,{id:"methods",children:"Methods"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Method 1: brute-force recursion: ",(0,s.jsx)(n.code,{children:"dfs(cur, target) = dfs(cur-1, target) or dfs(cur-1, target-nums[cur-1])"})]}),"\n",(0,s.jsxs)(n.li,{children:["Method 2: memoization: ",(0,s.jsx)(n.code,{children:"dfs(cur, target) = memo[cur, target] if memo[cur,target] != None else...."})]}),"\n",(0,s.jsx)(n.li,{children:"Method 3: 2-D dp:"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"implementations",children:"Implementations"}),"\n",(0,s.jsx)(n.h3,{id:"method-1-brute-force-recursion",children:"Method 1: brute-force recursion"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class Solution:\n    def canPartition(self, nums):\n        s = sum(nums)\n        target, mod = s // 2, s % 2\n        if mod == 1:\n            return False\n\n        def dfs(cur, target): \n        """this defines whether the array that ends with index on cur-1 has\n         subsets that sums up to target)"""\n            if target == 0:\n                return True\n            if target < 0:\n                return False\n            if cur == 0:\n                return False\n            return dfs(cur - 1, target) or dfs(cur - 1, target - nums[cur-1])\n\n        return dfs(len(nums), target)    \n'})}),"\n",(0,s.jsx)(n.h3,{id:"method-2-memoization",children:"Method 2: memoization"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"class Solution:\n    def canPartition(self, nums):\n        s = sum(nums)\n        target, mod = s // 2, s % 2\n        if mod == 1:\n            return False\n            \n        memo = [[None] * (target + 1)] * (len(nums) + 1)\n\n        def dfs(cur, target): \n            #this defines whether the array that ends with index on cur-1 has subsets that sums up to target)\n            if target == 0:\n                return True\n            if target < 0:\n                return False\n            if cur == 0:\n                return False\n            if memo[cur][target] != None:\n                return memo[cur][target]\n            res = dfs(cur - 1, target - nums[cur - 1]) or dfs(cur - 1, target)\n            memo[cur][target] = res\n            return res\n                \n        dfs(len(nums), target)\n\n        return memo[len(nums)][target]\n"})})]})}function l(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var r=t(96540);const s={},a=r.createContext(s);function i(e){const n=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);