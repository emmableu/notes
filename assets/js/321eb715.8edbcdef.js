"use strict";(globalThis.webpackChunknotes=globalThis.webpackChunknotes||[]).push([[54705],{28453:(e,n,s)=>{s.d(n,{R:()=>c,x:()=>a});var i=s(96540);const r={},t=i.createContext(r);function c(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:c(e.components),i.createElement(t.Provider,{value:n},e.children)}},97077:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>p,frontMatter:()=>c,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"Leetcode/Other/51.51 - N-Queens","title":"51.51 - N-Queens","description":"4\u4e2avis\uff1a","source":"@site/docs/03. Leetcode/99.Other/51.51 - N-Queens.md","sourceDirName":"03. Leetcode/99.Other","slug":"/p/487b3c7d-3dff-4ea8-aee5-6c42c22f57eb","permalink":"/notes/docs/p/487b3c7d-3dff-4ea8-aee5-6c42c22f57eb","draft":false,"unlisted":false,"editUrl":"https://github.com/emmableu/notes/edit/main/docs/03. Leetcode/99.Other/51.51 - N-Queens.md","tags":[],"version":"current","frontMatter":{"created_at":"2025-10-23","page_link":"/p/487b3c7d-3dff-4ea8-aee5-6c42c22f57eb","slug":"/p/487b3c7d-3dff-4ea8-aee5-6c42c22f57eb"},"sidebar":"tutorialSidebar","previous":{"title":"509.509 - Fibonacci Number - Easy","permalink":"/notes/docs/p/0c7f98ac-a319-4d40-ae10-e749667bf34b"},"next":{"title":"510.510 - Inorder Successor in BST II (Medium)","permalink":"/notes/docs/p/5ee2d528-3963-4ae1-b422-0728548dacf0"}}');var r=s(74848),t=s(28453);const c={created_at:"2025-10-23",page_link:"/p/487b3c7d-3dff-4ea8-aee5-6c42c22f57eb",slug:"/p/487b3c7d-3dff-4ea8-aee5-6c42c22f57eb"},a=void 0,o={},d=[];function l(e){const n={code:"code",img:"img",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{src:"https://raw.githubusercontent.com/emmableu/image/master/202209151913277.png",alt:""})}),"\n",(0,r.jsx)(n.p,{children:"4\u4e2avis\uff1a"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"                (r in vis_row) or \\  # \u76f8\u540c\u884c\n                (c in vis_col) or \\  # \u76f8\u540c\u5217\n                ((0, c - r) in vis_diag1) or \\ # \u2018\\\u2019\u65b9\u5411\u7684\u6700\u4e0a\u9762\u90a3\u4e2a \u7b80\u5316\u6210 (c - r) in vis_diag1\n                ((0, c + r) in vis_diag2)  # '/' \u65b9\u5411\u7684\u6700\u4e0a\u9762\u90a3\u4e2a, \u7b80\u5316\u6210 (c + r) in vis_diag2\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'class Solution:\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        res = []\n        vis_row, vis_col, vis_diag1, vis_diag2 = set(), set(), set(), set()\n        self.dfs([], res, n, vis_row, vis_col, vis_diag1, vis_diag2)\n        return res\n\n    def dfs(self, path, res, n, vis_row, vis_col, vis_diag1, vis_diag2):\n        if len(path) == n:\n            res.append(path.copy())\n        r = len(path)\n        for c in range(n):\n            if not (\n                (r in vis_row) or \\\n                (c in vis_col) or \\\n                (c - r in vis_diag1) or \\\n                (c + r in vis_diag2) \n            ):\n                vis_row.add(r)\n                vis_col.add(c)\n                vis_diag1.add(c - r)  # \u4ece vis_diag1.add((0, c - r)) \u7b80\u5316\u800c\u6765\n                vis_diag2.add(c + r)  # \u4ece vis_diag1.add((0, c + r)) \u7b80\u5316\u800c\u6765\n                \n                new_row = ["." for _ in range(n)]\n                new_row[c] = "Q"\n                path.append("".join(new_row))\n\n                self.dfs(path, res, n, vis_row, vis_col, vis_diag1, vis_diag2)\n\n                path.pop()\n\n                vis_row.remove(r)\n                vis_col.remove(c)\n                vis_diag1.remove(c - r)\n                vis_diag2.remove(c + r)\n'})})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}}}]);