"use strict";(globalThis.webpackChunknotes=globalThis.webpackChunknotes||[]).push([[18054],{28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var i=t(96540);const d={},s=i.createContext(d);function r(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(d):e.components||d:r(e.components),i.createElement(s.Provider,{value:n},e.children)}},63339:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>r,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"Leetcode/DFS/139.139 - Word Break - Medium","title":"139.139 - Word Break - Medium","description":"Description:","source":"@site/docs/03. Leetcode/04.DFS/139.139 - Word Break - Medium.md","sourceDirName":"03. Leetcode/04.DFS","slug":"/p/31df1555-fac7-4d51-9421-be815e50d2bf","permalink":"/notes/docs/p/31df1555-fac7-4d51-9421-be815e50d2bf","draft":false,"unlisted":false,"editUrl":"https://github.com/emmableu/notes/edit/main/docs/03. Leetcode/04.DFS/139.139 - Word Break - Medium.md","tags":[],"version":"current","frontMatter":{"created_at":"2025-10-23","page_link":"/p/31df1555-fac7-4d51-9421-be815e50d2bf","slug":"/p/31df1555-fac7-4d51-9421-be815e50d2bf"},"sidebar":"tutorialSidebar","previous":{"title":"1376.1376 - Time Needed to Inform All Employees - Medium","permalink":"/notes/docs/p/fccb7917-562b-43cd-9b98-e7070d823357"},"next":{"title":"140.140 - Word Break II - Hard","permalink":"/notes/docs/p/8b7ae095-02d9-4646-9cae-8a58b9ddd4a1"}}');var d=t(74848),s=t(28453);const r={created_at:"2025-10-23",page_link:"/p/31df1555-fac7-4d51-9421-be815e50d2bf",slug:"/p/31df1555-fac7-4d51-9421-be815e50d2bf"},o=void 0,l={},a=[{value:"Description:",id:"description",level:2},{value:"Examples",id:"examples",level:2},{value:"Methods",id:"methods",level:2},{value:"My solutions",id:"my-solutions",level:2},{value:"DP (shortest, most preferred)",id:"dp-shortest-most-preferred",level:3},{value:"DFS (time limit exceeds)",id:"dfs-time-limit-exceeds",level:3},{value:"DFS with memoization:",id:"dfs-with-memoization",level:3}];function c(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsx)(n.h2,{id:"description",children:"Description:"}),"\n",(0,d.jsx)(n.p,{children:"Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words."}),"\n",(0,d.jsx)(n.p,{children:"Note that the same word in the dictionary may be reused multiple times in the segmentation."}),"\n",(0,d.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:'Example 1:\n\nInput: s = "leetcode", wordDict = ["leet","code"]\nOutput: true\nExplanation: Return true because "leetcode" can be segmented as "leet code".\n\nExample 2:\nInput: s = "applepenapple", wordDict = ["apple","pen"]\nOutput: true\nExplanation: Return true because "applepenapple" can be segmented as "apple pen apple".\nNote that you are allowed to reuse a dictionary word.\n\nExample 3:\nInput: s = "catsandog", wordDict = ["cats","dog","sand","and","cat"]\nOutput: false\n'})}),"\n",(0,d.jsx)(n.p,{children:"Constraints:"}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsx)(n.li,{children:"1 <= s.length <= 300"}),"\n",(0,d.jsx)(n.li,{children:"1 <= wordDict.length <= 1000"}),"\n",(0,d.jsx)(n.li,{children:"1 <= wordDict[i].length <= 20"}),"\n",(0,d.jsx)(n.li,{children:"s and wordDict[i] consist of only lowercase English letters."}),"\n",(0,d.jsx)(n.li,{children:"All the strings of wordDict are unique."}),"\n"]}),"\n",(0,d.jsx)(n.h2,{id:"methods",children:"Methods"}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsx)(n.li,{children:"DFS (time limit exceeds)"}),"\n",(0,d.jsx)(n.li,{children:"DFS with memoization"}),"\n",(0,d.jsxs)(n.li,{children:["Bottom-Up DP\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsx)(n.li,{children:"for each character, save a boolean that's about whether it has or not has a dict."}),"\n",(0,d.jsx)(n.li,{children:"dp[i] = dp[i - k] & dp[i-k:i] in wordDict"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,d.jsx)(n.h2,{id:"my-solutions",children:"My solutions"}),"\n",(0,d.jsx)(n.h3,{id:"dp-shortest-most-preferred",children:"DP (shortest, most preferred)"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-python",children:"class Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n        dp = [True] + [False] * (len(s))\n        for i in range(1, len(s)+1):\n            for word in wordDict:\n                if s[:i].endswith(word):\n                    if dp[i-len(word)]:\n                        dp[i] = True\n                        break\n        return dp[len(s)]\n"})}),"\n",(0,d.jsx)(n.h3,{id:"dfs-time-limit-exceeds",children:"DFS (time limit exceeds)"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-python",children:"class Solution:\n    def wordBreak(self, s, wordDict):\n        word_dict = set(wordDict)\n        return self.dfs(s, word_dict, 0)\n        \n    def dfs(self, s, word_dict, idx):\n        if idx == len(s):\n            return True\n        for i in range(idx, len(s)):\n            if s[idx: i + 1] in word_dict:\n                if self.dfs(s, word_dict, i + 1):\n                    return True\n        return False\n"})}),"\n",(0,d.jsx)(n.h3,{id:"dfs-with-memoization",children:"DFS with memoization:"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:'s: "catsanddog"\nwordDict: ["cats", "cat", "and", "dog", "sand"]\nending memo: (n means None)\n  c   a   t   s   a   n   d   d   o   g\n[ t   n   n   t   n   n   n   t   n   n   t]\n\ns: "aaab"\nwordDict: ["a", "ab"]\nending memo: (n means None)\n  a   a   a   b\n[ t   t   t   f   t]\n'})}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{className:"language-python",children:"class Solution:\n    def wordBreak(self, s, wordDict):\n        word_dict = set(wordDict)\n        memo = [None] * len(s) + [True]\n        return self.dfs(s, word_dict, memo, 0)\n        \n    def dfs(self, s, word_dict, memo, idx):\n        if memo[idx] != None:\n            return memo[idx]\n        for i in range(idx, len(s)):\n            if s[idx: i + 1] in word_dict:\n                if self.dfs(s, word_dict, memo, i + 1):\n                    memo[idx] = True\n                    return True\n        memo[idx] = False\n        # \u6240\u6709 i in range(idx, len(s)) \u90fd\u904d\u5386\u8fc7\u8fd8\u662f\u627e\u4e0d\u5230\uff0c\u6240\u4ee5memo[idx] \u662ffalse\n        return False\n"})})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,d.jsx)(n,{...e,children:(0,d.jsx)(c,{...e})}):c(e)}}}]);