"use strict";(self.webpackChunknotes=self.webpackChunknotes||[]).push([[3795],{28453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>c});var s=n(96540);const r={},o=s.createContext(r);function i(e){const t=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(o.Provider,{value:t},e.children)}},32014:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>c,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"Leetcode/Other/1305.1305 - All Elements in Two Binary Search Trees - Medium","title":"1305.1305 - All Elements in Two Binary Search Trees - Medium","description":"LC link","source":"@site/docs/Leetcode/99.Other/1305.1305 - All Elements in Two Binary Search Trees - Medium.md","sourceDirName":"Leetcode/99.Other","slug":"/p/7dcc5d77-209e-4db6-9a42-63a1c3c01620","permalink":"/notes/docs/p/7dcc5d77-209e-4db6-9a42-63a1c3c01620","draft":false,"unlisted":false,"editUrl":"https://github.com/emmableu/notes/edit/main/docs/Leetcode/99.Other/1305.1305 - All Elements in Two Binary Search Trees - Medium.md","tags":[],"version":"current","frontMatter":{"created_at":"2025-10-23","page_link":"/p/7dcc5d77-209e-4db6-9a42-63a1c3c01620","slug":"/p/7dcc5d77-209e-4db6-9a42-63a1c3c01620"},"sidebar":"tutorialSidebar","previous":{"title":"1302.1302 - Deepest Leaves Sum - Medium","permalink":"/notes/docs/p/ce4a52b8-a3cd-48b2-8d78-64b0d2dc04d6"},"next":{"title":"1344.1344 - Angle Between Hands of a Clock (Medium)","permalink":"/notes/docs/p/7d229e8b-f632-4253-b39b-b31a92ffcc75"}}');var r=n(74848),o=n(28453);const i={created_at:"2025-10-23",page_link:"/p/7dcc5d77-209e-4db6-9a42-63a1c3c01620",slug:"/p/7dcc5d77-209e-4db6-9a42-63a1c3c01620"},c=void 0,l={},a=[{value:"Solution:",id:"solution",level:2}];function d(e){const t={a:"a",code:"code",h2:"h2",img:"img",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.a,{href:"https://leetcode.com/problems/all-elements-in-two-binary-search-trees/",children:"LC link"}),"\n",(0,r.jsx)(t.img,{src:"https://raw.githubusercontent.com/emmableu/image/master/1305-0.png",alt:""})]}),"\n",(0,r.jsx)(t.h2,{id:"solution",children:"Solution:"}),"\n",(0,r.jsx)(t.p,{children:"\u5148\u505ainorder traversal\uff0c\u518d\u628a\u7ed3\u679cmerge\u5230\u4e00\u4e2a\u53ebres\u7684list\u91cc\u9762\u3002"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:"class Solution:\n    def getAllElements(self, root1, root2):\n        def inorder(root, lst):\n            if not root: return\n            inorder(root.left, lst)\n            lst.append(root.val)\n            inorder(root.right, lst)\n        \n        lst1, lst2 = [], []\n        inorder(root1, lst1)\n        inorder(root2, lst2)\n        \n        i1, i2, res = 0, 0, []\n        s1, s2 = len(lst1), len(lst2)\n        \n        while i1 < s1 and i2 < s2:\n            if lst1[i1] < lst2[i2]:\n                res.append(lst1[i1])\n                i1 += 1\n            else:\n                res.append(lst2[i2])\n                i2 += 1\n                \n        return res + lst1[i1:] + lst2[i2:]\n"})})]})}function u(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);