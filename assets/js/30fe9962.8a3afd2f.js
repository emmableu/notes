"use strict";(globalThis.webpackChunknotes=globalThis.webpackChunknotes||[]).push([[16591],{2194:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>p,frontMatter:()=>r,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"Leetcode/Other/23.23 - Merge k Sorted Lists - Hard","title":"23.23 - Merge k Sorted Lists - Hard","description":"LC link","source":"@site/docs/03. Leetcode/99.Other/23.23 - Merge k Sorted Lists - Hard.md","sourceDirName":"03. Leetcode/99.Other","slug":"/p/f120bf78-9ee7-488a-9cbc-8c1c265b1457","permalink":"/notes/docs/p/f120bf78-9ee7-488a-9cbc-8c1c265b1457","draft":false,"unlisted":false,"editUrl":"https://github.com/emmableu/notes/edit/main/docs/03. Leetcode/99.Other/23.23 - Merge k Sorted Lists - Hard.md","tags":[],"version":"current","frontMatter":{"created_at":"2025-10-23","page_link":"/p/f120bf78-9ee7-488a-9cbc-8c1c265b1457","slug":"/p/f120bf78-9ee7-488a-9cbc-8c1c265b1457"},"sidebar":"tutorialSidebar","previous":{"title":"227.227 - Basic Calculator II (Medium)","permalink":"/notes/docs/p/412d0110-6b23-4927-a687-c0c5a82c7a4e"},"next":{"title":"234.234 - Palindrome Linked List - Easy","permalink":"/notes/docs/p/5a1d2798-f1dd-47d6-9cc1-1c808683a033"}}');var i=t(74848),l=t(28453);const r={created_at:"2025-10-23",page_link:"/p/f120bf78-9ee7-488a-9cbc-8c1c265b1457",slug:"/p/f120bf78-9ee7-488a-9cbc-8c1c265b1457"},o=void 0,a={},d=[{value:"Description",id:"description",level:2},{value:"Examples",id:"examples",level:2},{value:"Solution",id:"solution",level:2},{value:"1. Divide and conquer (time O (n * log(k)), space O(1)) (preferred)",id:"1-divide-and-conquer-time-o-n--logk-space-o1-preferred",level:3},{value:"2. heapq (time O (n * log(k)), space O(k))",id:"2-heapq-time-o-n--logk-space-ok",level:3}];function c(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,l.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://leetcode.com/problems/merge-k-sorted-lists/",children:"LC link"})}),"\n",(0,i.jsx)(n.h2,{id:"description",children:"Description"}),"\n",(0,i.jsx)(n.p,{children:"You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\nMerge all the linked-lists into one sorted linked-list and return it."}),"\n",(0,i.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Example 1:\nInput: lists = [[1,4,5],[1,3,4],[2,6]]\nOutput: [1,1,2,3,4,4,5,6]\nExplanation: The linked-lists are:\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\nmerging them into one sorted list:\n1->1->2->3->4->4->5->6\n\nExample 2:\nInput: lists = []\nOutput: []\n\nExample 3:\nInput: lists = [[]]\nOutput: []\n"})}),"\n",(0,i.jsx)(n.h2,{id:"solution",children:"Solution"}),"\n",(0,i.jsx)(n.h3,{id:"1-divide-and-conquer-time-o-n--logk-space-o1-preferred",children:"1. Divide and conquer (time O (n * log(k)), space O(1)) (preferred)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class Solution:\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\n        if not lists:return \n        n = len(lists)\n        return self.merge(lists, 0, n-1)\n    \n    def merge(self,lists, left, right):\n        if left == right:\n            return lists[left]\n        mid = (left + right) // 2\n        l1 = self.merge(lists, left, mid)\n        l2 = self.merge(lists, mid+1, right)\n        return self.mergeTwo(l1, l2)\n    \n    def mergeTwo(self,l1, l2):\n        if not l1:return l2\n        if not l2:return l1\n        if l1.val < l2.val:\n            l1.next = self.mergeTwo(l1.next, l2)\n            return l1\n        else:\n            l2.next = self.mergeTwo(l1, l2.next)\n            return l2\n"})}),"\n",(0,i.jsx)(n.h3,{id:"2-heapq-time-o-n--logk-space-ok",children:"2. heapq (time O (n * log(k)), space O(k))"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import heapq\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        res = ListNode(None)\n        cur = res\n        h = []\n        for (i, node) in enumerate(lists):\n            if node:\n                # must have i, otherwise when node.val is the same, \n                # it won't know how to be sorted.\n                heapq.heappush(h, (node.val, i, node))\n        while len(h) > 0:\n            nxt = heapq.heappop(h)\n            cur.next = ListNode(nxt[0])\n            add = nxt[2].next\n            if add:\n                heapq.heappush(h, (add.val, nxt[1], add))\n            cur = cur.next\n        return res.next\n"})})]})}function p(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var s=t(96540);const i={},l=s.createContext(i);function r(e){const n=s.useContext(l);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(l.Provider,{value:n},e.children)}}}]);