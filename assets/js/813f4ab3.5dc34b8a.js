"use strict";(globalThis.webpackChunknotes=globalThis.webpackChunknotes||[]).push([[19837],{28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>r});var o=t(96540);const l={},a=o.createContext(l);function i(e){const n=o.useContext(a);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:i(e.components),o.createElement(a.Provider,{value:n},e.children)}},46592:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"Leetcode/Other/1161.1161 - Maximum Level Sum of a Binary Tree (Medium)","title":"1161.1161 - Maximum Level Sum of a Binary Tree (Medium)","description":"LC link","source":"@site/docs/03. Leetcode/99.Other/1161.1161 - Maximum Level Sum of a Binary Tree (Medium).md","sourceDirName":"03. Leetcode/99.Other","slug":"/p/3f39a542-5f5c-49f8-99ec-2884c1b845fd","permalink":"/notes/docs/p/3f39a542-5f5c-49f8-99ec-2884c1b845fd","draft":false,"unlisted":false,"editUrl":"https://github.com/emmableu/notes/edit/main/docs/03. Leetcode/99.Other/1161.1161 - Maximum Level Sum of a Binary Tree (Medium).md","tags":[],"version":"current","frontMatter":{"created_at":"2025-10-23","page_link":"/p/3f39a542-5f5c-49f8-99ec-2884c1b845fd","slug":"/p/3f39a542-5f5c-49f8-99ec-2884c1b845fd"},"sidebar":"tutorialSidebar","previous":{"title":"116.116 - Populating Next Right Pointers in Each Node (Medium)","permalink":"/notes/docs/p/4bbb81da-1a8f-4756-8c34-90032f4a7011"},"next":{"title":"1168.1168 - Optimize Water Distribution in a Village (Hard)","permalink":"/notes/docs/p/6a76cb64-cb3f-415b-a333-c9c020512322"}}');var l=t(74848),a=t(28453);const i={created_at:"2025-10-23",page_link:"/p/3f39a542-5f5c-49f8-99ec-2884c1b845fd",slug:"/p/3f39a542-5f5c-49f8-99ec-2884c1b845fd"},r=void 0,s={},c=[{value:"Solution: BFS",id:"solution-bfs",level:2}];function u(e){const n={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.p,{children:(0,l.jsx)(n.a,{href:"https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree/",children:"LC link"})}),"\n",(0,l.jsx)(n.p,{children:"Given the root of a binary tree, the level of its root is 1, the level of its children is 2, and so on."}),"\n",(0,l.jsx)(n.p,{children:"Return the smallest level x such that the sum of all the values of nodes at level x is maximal."}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{children:"Example 1:\nInput: root = [1,7,0,7,-8,null,null]\nOutput: 2\nExplanation: \nLevel 1 sum = 1.\nLevel 2 sum = 7 + 0 = 7.\nLevel 3 sum = 7 + -8 = -1.\nSo we return the level with the maximum sum which is level 2.\n\nExample 2:\nInput: root = [989,null,10250,98693,-89388,null,null,null,-32127]\nOutput: 2\n"})}),"\n",(0,l.jsx)(n.h2,{id:"solution-bfs",children:"Solution: BFS"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-python",children:"class Solution:\n    def maxLevelSum(self, root: TreeNode) -> int:\n        maxsum, level, maxLevel = -float('inf'), 0, 0\n        q = collections.deque()\n        q.append(root)\n        while q:\n            level += 1\n            cursum = 0\n            for _ in range(len(q)):\n                node = q.popleft()\n                cursum += node.val\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            if maxsum < cursum:\n                maxsum, maxLevel = cursum, level        \n        return maxLevel\n"})})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(u,{...e})}):u(e)}}}]);