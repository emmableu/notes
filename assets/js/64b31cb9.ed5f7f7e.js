"use strict";(self.webpackChunknotes=self.webpackChunknotes||[]).push([[387],{28453:(e,n,o)=>{o.d(n,{R:()=>l,x:()=>i});var t=o(96540);const r={},c=t.createContext(r);function l(e){const n=t.useContext(c);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),t.createElement(c.Provider,{value:n},e.children)}},77714:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>a,contentTitle:()=>i,default:()=>p,frontMatter:()=>l,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"Leetcode/Other/987.987 - Vertical Order Traversal of a Binary Tree (Hard)","title":"987.987 - Vertical Order Traversal of a Binary Tree (Hard)","description":"LC link","source":"@site/docs/Leetcode/99.Other/987.987 - Vertical Order Traversal of a Binary Tree (Hard).md","sourceDirName":"Leetcode/99.Other","slug":"/p/836c7fc4-b488-4bae-b71a-44117bd52c84","permalink":"/notes/docs/p/836c7fc4-b488-4bae-b71a-44117bd52c84","draft":false,"unlisted":false,"editUrl":"https://github.com/emmableu/notes/edit/main/docs/Leetcode/99.Other/987.987 - Vertical Order Traversal of a Binary Tree (Hard).md","tags":[],"version":"current","frontMatter":{"created_at":"2025-10-23","page_link":"/p/836c7fc4-b488-4bae-b71a-44117bd52c84","slug":"/p/836c7fc4-b488-4bae-b71a-44117bd52c84"},"sidebar":"tutorialSidebar","previous":{"title":"986.986 - Interval List Intersections - Medium","permalink":"/notes/docs/p/d42c575b-2ddd-41ae-a30a-5365b722325a"},"next":{"title":"Minimum Path Sum","permalink":"/notes/docs/p/13df70c2-9268-496e-99e8-6b229c8ca971"}}');var r=o(74848),c=o(28453);const l={created_at:"2025-10-23",page_link:"/p/836c7fc4-b488-4bae-b71a-44117bd52c84",slug:"/p/836c7fc4-b488-4bae-b71a-44117bd52c84"},i=void 0,a={},d=[{value:"Example",id:"example",level:2},{value:"Solution 1\uff1aBFS",id:"solution-1bfs",level:2},{value:"Solution 2\uff1aDFS",id:"solution-2dfs",level:2}];function s(e){const n={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",...(0,c.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/",children:"LC link"})}),"\n",(0,r.jsxs)(n.p,{children:["\u672c\u9898\u548c ",(0,r.jsx)(n.a,{href:"https://emmableu.github.io/blog/pages/leetcode314",children:"314"}),"\u7c7b\u4f3c\uff0c\u533a\u522b\u5728\u4e8e\u672c\u9898\u51fa\u6765\u7684\u76f8\u540clevel\u662fsorted\uff0c\u6240\u4ee5\u533a\u522b\u4e8e314\uff0c\u8fd8\u8981\u5728",(0,r.jsx)(n.code,{children:"col_dict"}),"\u4e2d\u5b58row number"]}),"\n",(0,r.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Input: root = [1,2,3,4,6,5,7]\nOutput: [[4],[2],[1,5,6],[3],[7]]\nExplanation:\nThis case is the exact same as example 2, but with nodes 5 and 6 swapped.\nNote that the solution remains the same since 5 and 6 are in the same location and should be ordered by their values.\n"})}),"\n",(0,r.jsx)(n.h2,{id:"solution-1bfs",children:"Solution 1\uff1aBFS"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"col_dict"}),": ",(0,r.jsx)(n.code,{children:"{0: [(0, 3), (2, 15)], -1: [(1, 9)], 1: [(1, 20)], 2: [(2, 7)]})"}),"\n- key \u662f column\u7684order\uff0cvalue\u91cc\u9762\u7684list\u91cc\u9762\u6bcf\u4e00\u4e2atuple\u90fd\u662f (row_order, node.val)\n",(0,r.jsx)(n.code,{children:"min_col"}),", ",(0,r.jsx)(n.code,{children:"max_col"}),": \u8bb0\u5f55res\u8981\u600e\u4e48iterate\uff0c\u4e5f\u53ef\u4ee5\u6ca1\u6709\uff0c\u5c31\u76f4\u63a5\u628adict\u7684keys\u91cd\u65b0sort\uff0c\u8fd9\u6837\u590d\u6742\u5ea6\u7a0d\u5fae\u9ad8\u4e86\u4e00\u70b9\u70b9\uff0c\u4f46\u662f\u4e5f\u6ca1\u6709\u592a\u591a\u3002"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class Solution:\n    def verticalTraversal(self, root):\n        if not root:\n            return []\n        col_dict = defaultdict(list)\n        col, row, min_col, max_col = 0, 0, 0, 0\n        q = deque([(col, row, root)])\n        # q: [(0, 0, 1)]\n        while q:\n            size = len(q)\n            for _ in range(size):\n                ele = q.popleft()\n                col, row, node = ele\n                if not node:\n                    continue\n                col_dict[col].append((row + 1, node.val))\n                min_col = min(col, min_col)\n                max_col = max(col, max_col)\n                q.extend([(col-1, row + 1, node.left), (col + 1, row + 1, node.right)])\n        # col_dict: {0: [(1, 1), (3, 6), (3, 5)], -1: [(2, 2)], 1: [(2, 3)], -2: [(3, 4)], 2: [(3, 7)]})\n        res = []\n        for i in range(min_col, max_col + 1):\n            # *sorted(col_dict[i]): (1, 1) (3, 5) (3, 6)\n            # list(zip(*sorted(col_dict[i])))): [(1, 3, 3), (1, 5, 6)]\n            res.append(list(zip(*sorted(col_dict[i])))[1])\n        return res\n"})}),"\n",(0,r.jsx)(n.h2,{id:"solution-2dfs",children:"Solution 2\uff1aDFS"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"col_dict"}),": ",(0,r.jsx)(n.code,{children:"{0: [(0, 3), (2, 15)], -1: [(1, 9)], 1: [(1, 20)], 2: [(2, 7)]})"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"class Solution:\n    def verticalTraversal(self, root):\n\n        def dfs(col_dict, row, col, root):\n            if not root:\n                return \n            col_dict[col].append((row, root.val))\n            dfs(col_dict, row + 1, col - 1, root.left)\n            dfs(col_dict, row + 1, col + 1, root.right)\n\n        col_dict = defaultdict(list)\n        dfs(col_dict, 0, 0, root)\n        res = []\n        for k in sorted(col_dict.keys()):\n            col_data = col_dict[k]\n            res.append(list(zip(*sorted(col_data)))[1])\n        return res\n"})})]})}function p(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(s,{...e})}):s(e)}}}]);