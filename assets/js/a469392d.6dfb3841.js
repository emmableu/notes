"use strict";(globalThis.webpackChunknotes=globalThis.webpackChunknotes||[]).push([[14601],{16679:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>n,metadata:()=>r,toc:()=>h});const r=JSON.parse('{"id":"ML General/Feature Selection","title":"Feature Selection","description":"wikipedia","source":"@site/docs/05. ML General/09.Feature Selection.md","sourceDirName":"05. ML General","slug":"/p/780d6a08-9052-48b8-be65-8e0aa46e3ffb","permalink":"/notes/docs/p/780d6a08-9052-48b8-be65-8e0aa46e3ffb","draft":false,"unlisted":false,"editUrl":"https://github.com/emmableu/notes/edit/main/docs/05. ML General/09.Feature Selection.md","tags":[],"version":"current","sidebarPosition":9,"frontMatter":{"created_at":"2025-11-02","page_link":"/p/780d6a08-9052-48b8-be65-8e0aa46e3ffb","slug":"/p/780d6a08-9052-48b8-be65-8e0aa46e3ffb"},"sidebar":"tutorialSidebar","previous":{"title":"Classification Metric","permalink":"/notes/docs/p/40c27ac6-55a8-4fa7-94a2-9e0ea4b0976d"},"next":{"title":"Regularization","permalink":"/notes/docs/p/74afc8cf-1b32-4848-b8ca-8a61fa8f137b"}}');var i=s(74848),a=s(28453);const n={created_at:"2025-11-02",page_link:"/p/780d6a08-9052-48b8-be65-8e0aa46e3ffb",slug:"/p/780d6a08-9052-48b8-be65-8e0aa46e3ffb"},o=void 0,l={},h=[{value:"Wrapper Methods",id:"wrapper-methods",level:2},{value:"Stepwise Regression",id:"stepwise-regression",level:3},{value:"Optimality criteria",id:"optimality-criteria",level:4},{value:"Filter Methods",id:"filter-methods",level:2},{value:"Comparing filter with wrapper methods:",id:"comparing-filter-with-wrapper-methods",level:4},{value:"Embedded Methods",id:"embedded-methods",level:2},{value:"Using Search Algorithms To Select Features",id:"using-search-algorithms-to-select-features",level:2},{value:"Filter metrics when using search algorrithems:",id:"filter-metrics-when-using-search-algorrithems",level:3}];function c(e){const t={a:"a",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Feature_selection#Subset_selection",children:"wikipedia"})}),"\n",(0,i.jsx)(t.h2,{id:"wrapper-methods",children:"Wrapper Methods"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.img,{src:"https://raw.githubusercontent.com/emmableu/image/master/feature-selection-2.png",alt:""}),"\nWrapper methods use a predictive model to score feature subsets. Each new subset is used to train a model, which is tested on a hold-out set. Counting the number of mistakes made on that hold-out set (the error rate of the model) gives the score for that subset. As wrapper methods train a new model for each subset, they are very computationally intensive, but usually provide the best performing feature set for that particular type of model or typical problem."]}),"\n",(0,i.jsx)(t.h3,{id:"stepwise-regression",children:"Stepwise Regression"}),"\n",(0,i.jsx)(t.p,{children:"In traditional regression analysis, the most popular form of feature selection is stepwise regression, which is a wrapper technique. It is a greedy algorithm that adds the best feature (or deletes the worst feature) at each round. The main control issue is deciding when to stop the algorithm. In machine learning, this is typically done by cross-validation. In statistics, some criteria are optimized (see bellow - optimality criteria). This leads to the inherent problem of nesting. More robust methods have been explored, such as branch and bound and piecewise linear network."}),"\n",(0,i.jsx)(t.h4,{id:"optimality-criteria",children:"Optimality criteria"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{src:"https://raw.githubusercontent.com/emmableu/image/master/feature-selection-0.png",alt:""})}),"\n",(0,i.jsx)(t.h2,{id:"filter-methods",children:"Filter Methods"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{src:"https://raw.githubusercontent.com/emmableu/image/master/feature-selection-1.png",alt:""})}),"\n",(0,i.jsx)(t.p,{children:"Filter methods use a proxy measure instead of the error rate to score a feature subset. This measure is chosen to be fast to compute, while still capturing the usefulness of the feature set. Common measures include the mutual information, the pointwise mutual information, Pearson product-moment correlation coefficient, Relief-based algorithms, and inter/intra class distance or the scores of significance tests for each class/feature combinations."}),"\n",(0,i.jsx)(t.p,{children:"Many filters provide a feature ranking rather than an explicit best feature subset, and the cut off point in the ranking is chosen via cross-validation."}),"\n",(0,i.jsx)(t.h4,{id:"comparing-filter-with-wrapper-methods",children:"Comparing filter with wrapper methods:"}),"\n",(0,i.jsx)(t.p,{children:"Filters are usually less computationally intensive than wrappers, but they produce a feature set which is not tuned to a specific type of predictive model."}),"\n",(0,i.jsx)(t.p,{children:"This lack of tuning means a feature set from a filter is more general than the set from a wrapper, usually giving lower prediction performance than a wrapper. However the feature set doesn't contain the assumptions of a prediction model, and so is more useful for exposing the relationships between the features."}),"\n",(0,i.jsx)(t.p,{children:"Filter methods have also been used as a preprocessing step for wrapper methods, allowing a wrapper to be used on larger problems. One other popular approach is the Recursive Feature Elimination algorithm, commonly used with Support Vector Machines to repeatedly construct a model and remove features with low weights."}),"\n",(0,i.jsx)(t.h2,{id:"embedded-methods",children:"Embedded Methods"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.img,{src:"https://raw.githubusercontent.com/emmableu/image/master/feature-selection-3.png",alt:""}),"\nEmbedded methods are a catch-all group of techniques which perform feature selection as part of the model construction process. The exemplar of this approach is the LASSO method for constructing a linear model, which penalizes the regression coefficients with an L1 penalty, shrinking many of them to zero. Any features which have non-zero regression coefficients are 'selected' by the LASSO algorithm."]}),"\n",(0,i.jsx)(t.h2,{id:"using-search-algorithms-to-select-features",children:"Using Search Algorithms To Select Features"}),"\n",(0,i.jsx)(t.p,{children:"these search-based methods can be used in both wrapper and filter methods."}),"\n",(0,i.jsxs)(t.p,{children:["Many popular search approaches use ",(0,i.jsx)(t.strong,{children:"greedy hill climbing"}),", which iteratively evaluates a candidate subset of features, then modifies the subset and evaluates if the new subset is an improvement over the old. Evaluation of the subsets requires a scoring metric that grades a subset of features. Exhaustive search is generally impractical, so at some implementor (or operator) defined stopping point, the subset of features with the highest score discovered up to that point is selected as the satisfactory feature subset. The stopping criterion varies by algorithm; possible criteria include: a subset score exceeds a threshold, a program's maximum allowed run time has been surpassed, etc."]}),"\n",(0,i.jsxs)(t.p,{children:["Alternative search-based techniques are based on ",(0,i.jsx)(t.strong,{children:"targeted projection pursuit"})," which finds low-dimensional projections of the data that score highly: the features that have the largest projections in the lower-dimensional space are then selected."]}),"\n",(0,i.jsx)(t.h3,{id:"filter-metrics-when-using-search-algorrithems",children:"Filter metrics when using search algorrithems:"}),"\n",(0,i.jsx)(t.p,{children:"Two popular filter metrics for classification problems are correlation and mutual information, although neither are true metrics or 'distance measures' in the mathematical sense, since they fail to obey the triangle inequality and thus do not compute any actual 'distance' \u2013 they should rather be regarded as 'scores'. These scores are computed between a candidate feature (or set of features) and the desired output category. There are, however, true metrics that are a simple function of the mutual information;[30] see here."}),"\n",(0,i.jsx)(t.p,{children:"Other available filter metrics include:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Class separability"}),"\n",(0,i.jsx)(t.li,{children:"Error probability"}),"\n",(0,i.jsx)(t.li,{children:"Inter-class distance"}),"\n",(0,i.jsx)(t.li,{children:"Probabilistic distance"}),"\n",(0,i.jsx)(t.li,{children:"Entropy"}),"\n",(0,i.jsx)(t.li,{children:"Consistency-based feature selection"}),"\n",(0,i.jsx)(t.li,{children:"Correlation-based feature selection"}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},28453:(e,t,s)=>{s.d(t,{R:()=>n,x:()=>o});var r=s(96540);const i={},a=r.createContext(i);function n(e){const t=r.useContext(a);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:n(e.components),r.createElement(a.Provider,{value:t},e.children)}}}]);